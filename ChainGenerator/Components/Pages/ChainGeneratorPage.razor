@page "/"
@using System.Text.Json

@inject IJSRuntime JSRuntime

<MudTextField 
    @bind-Value="userPrompt" 
    @onkeydown="@OnKeyDown" 
    Immediate="true" 
    Label="New Generator Title" 
    HelperText="" 
    Variant="Variant.Outlined" 
    AdornmentIcon="@Icons.Material.Filled.Add"
    Adornment="Adornment.End"
    OnAdornmentClick="Submit"/>
<br />
<MudFileUpload T="IBrowserFile" FilesChanged="Import">
    <ButtonTemplate>
        <MudButtonGroup Color="Color.Primary" Variant="Variant.Outlined">
            <MudButton StartIcon="@Icons.Material.Filled.Save" aria-label="delete" OnClick="Download">Save Generators</MudButton>
            <MudButton StartIcon="@Icons.Material.Filled.UploadFile" aria-label="upload file" for="@context.Id" HtmlTag="label">Import Generator</MudButton>
        </MudButtonGroup>
    </ButtonTemplate>
</MudFileUpload>
<br />

<MudGrid Justify="Justify.SpaceEvenly">
    @foreach (var generator in generators)
    {
        <MudItem xs="12" md="6" xl="4">
            <WidgetText WidgetTextGenerator="@generator"
                        OnRefresh="OnGeneratorRefresh"
                        OnDelete="() => OnDelete(generator)"
                        Parent="@this" />
        </MudItem>
    }
</MudGrid>

@code {
    private List<WidgetText> widgetTexts = new List<WidgetText>();
    private List<WidgetTextGenerator> generators = new List<WidgetTextGenerator>
    {
        new WidgetTextGenerator
        {
            Title = "Test",
        },
    };
    private IJSObjectReference? module;
    private string userPrompt { get; set; } = "";

    protected override async Task OnAfterRenderAsync(bool firstRender)
    {
        if (firstRender)
        {
            module = await JSRuntime.InvokeAsync<IJSObjectReference>("import", "./js/chainGenerator.js");
        }
    }

    private async Task OnKeyDown(KeyboardEventArgs e)
    {
        if (e.Code == "Enter" || e.Code == "NumpadEnter")
        {
            await Submit();
        }
    }

    private async Task Import(IBrowserFile browserFile)
    {
        // Read the file and deserialize it into a list of generators
        var content = await new StreamReader(browserFile.OpenReadStream()).ReadToEndAsync();        
        var newGenerators = JsonSerializer.Deserialize<List<WidgetTextGenerator>>(content);
        if (newGenerators != null)
        {
            for (int i = generators.Count - 1; i >= 0; i--)
            {
                generators.RemoveAt(i);
            }
            foreach (var newGenerator in newGenerators)
            {                
                generators.Add(newGenerator);
            }
        }
    }

    private async Task Download()
    {
        // Download the generators as a json file
        var json = JsonSerializer.Serialize(generators);
        await module.InvokeVoidAsync("download", json, "generators.json", "application/json");
    }

    private async Task Submit()
    {
        var originalPrompt = userPrompt;
        // Check if any widgets have the title matching the user prompt and update the user prompt to a unique title
        if (widgetTexts.Any(x => x.WidgetTextGenerator.Title == userPrompt))
        {
            userPrompt = userPrompt + " (1)";
            var i = 2;
            while (widgetTexts.Any(x => x.WidgetTextGenerator.Title == userPrompt))
            {
                userPrompt = userPrompt.Replace($" ({i - 1})", $" ({i})");
                i++;
            }
        }

        generators.Add(new WidgetTextGenerator
            {
                Title = userPrompt,
            });
        userPrompt = originalPrompt;
    }

    public void AddWidgetText(WidgetText widgetText)
    {
        widgetTexts.Add(widgetText);
    }

    private void OnDelete(WidgetTextGenerator widgetTextGenerator)
    {
        generators.Remove(widgetTextGenerator);
    }

    private async Task OnGeneratorRefresh(WidgetText refreshTargetWidgetText)
    {
        await InternalOnGeneratorRefresh(refreshTargetWidgetText);
    }

    private async Task InternalOnGeneratorRefresh(WidgetText refreshTargetWidgetText, List<WidgetText>? alreadyRefershedWidgets = null)
    {
        alreadyRefershedWidgets ??= new List<WidgetText>();
        if (alreadyRefershedWidgets.Contains(refreshTargetWidgetText))
        {
            return;
        }
        alreadyRefershedWidgets.Add(refreshTargetWidgetText);

        // Reset the generated prompt incase any references were updated
        refreshTargetWidgetText.WidgetTextGenerator.GeneratedPrompt = refreshTargetWidgetText.WidgetTextGenerator.Prompt;

        // Set the target widgets genearted prompt from the references and generate
        foreach (var referencedWidget in refreshTargetWidgetText.WidgetTextGenerator.GetGeneratorReferences())
        {
            foreach (var generator in generators)
            {
                if (generator.Title == referencedWidget)
                {
                    refreshTargetWidgetText.WidgetTextGenerator.GeneratedPrompt = refreshTargetWidgetText.WidgetTextGenerator.GeneratedPrompt.Replace("{{" + referencedWidget + "}}", generator.GetFinalOutput());
                }
            }
        }
        await refreshTargetWidgetText.Refresh();

        // See if any other widget references this one because it should now be re-generated if it does
        var referenceTargetTasks = new List<Task>();
        foreach (var widgetText in widgetTexts)
        {
            if (widgetText.WidgetTextGenerator.GetGeneratorReferences().Contains(refreshTargetWidgetText.WidgetTextGenerator.Title))
            {
                referenceTargetTasks.Add(InternalOnGeneratorRefresh(widgetText, alreadyRefershedWidgets));
            }
        }
        await Task.WhenAll(referenceTargetTasks);
    }
}
